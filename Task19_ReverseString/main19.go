package main

import (
	"bufio"
	"fmt"
	"io"
	"os"
	"strings"
)

// reverseString разворачивает входную строку по Unicode-кодовым точкам (runes).

func reverseString(s string) string {
	// преобразуем строку в срез рун (декодирует UTF-8 в последов-ть int32 (rune))
	runes := []rune(s)

	// разворачиваем срез рун (два указателя): временная (доп.) память не выделяется для 2го среза, только для исходного []rune
	for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
		runes[i], runes[j] = runes[j], runes[i]
	}

	// собираем строку обратно из среза рун и получаем корректный UTF-8
	return string(runes)
}

func main() {
	// bufio.Reader + ReadString('\n'), чтобы читать строку целиком (в т.ч. пробелы) и корректно работать и при интерактивном запуске и при конвейре (pipe)
	reader := bufio.NewReader(os.Stdin)

	fmt.Print("Введите строку: ")

	// readString читает до символа '\n' включительно или до EOF
	line, err := reader.ReadString('\n')
	// если произошла ошибка чтения, разрешаем io.EOF (в случае, если ввод был через pipe и без '\n'), иначе считаем это error
	if err != nil && err != io.EOF {
		// пишем ошибку в stderr и выходим с ненулевым кодом
		fmt.Fprintln(os.Stderr, "Ошибка чтения:", err)
		os.Exit(1)
	}

	// убираем завершающие символы перевода строки (\n, \r\n), но НЕ тримим другие пробелы, т.к. они могут быть значимы.
	input := strings.TrimRight(line, "\r\n")

	// вызываем функцию разворота и печатаем результат
	fmt.Println("Разворот:", reverseString(input))
}

/*
Разворот строки
Разработать программу, которая переворачивает подаваемую на вход строку.
Например: при вводе строки «главрыба» вывод должен быть «абырвалг».
Учтите, что символы могут быть в Unicode (русские буквы, emoji и пр.),
то есть просто iterating по байтам может не подойти — нужен срез рун ([]rune).
*/
