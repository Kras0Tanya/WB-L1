/*
Небольшой фрагмент кода — проблемы и решение

Рассмотреть следующий код и ответить на вопросы: к каким негативным последствиям он может привести и как это исправить?
Приведите корректный пример реализации.

var justString string

func someFunc() {
  v := createHugeString(1 &lt;&lt; 10)
  justString = v[:100]
}

func main() {
  someFunc()
}

Вопрос: что происходит с переменной justString?
*/

/*
Небольшое примечание:
в исходном коде задачи используется v := createHugeString(1 &lt;&lt; 10)
однако компилятор Go не распознает такой "синтаксис"
поиск дал ответ, что &lt;&lt; - это HTML-escape для <<
v := createHugeString(1 << 10)
это верный вариант синтаксиса, побитовый сдвиг влево, который в данном случае даёт число 1024

Вопросы: что происходит с переменной justString?
К каким негативным последствиям он (код) может привести и как это исправить?
Ответ:
justString - глобальная строковая переменная,
в коде justString = v[:100]
justString ссылается на часть памяти большой строки v
В Go строки хранятся как структура с указателем на массив байтов и длиной.
При срезе (v[:100]) новая строка не копирует данные, а указывает на тот же массив байтов, что и v.
В памяти остаётся вся строка v
Нужны только первые 100 символов, но глобальная переменная продолжает держать ссылку на всю память v.
И сборщик мусора не сможет сразу освободить её.
Поскольку justString глобальная, она будет существовать всё время работы программы,
а вместе с ней и весь большой массив байтов от v

Это может привести к следующим негативным последствиям:
1. Утечка памяти
Каждый вызов someFunc создаёт большую строку v и сохраняет в justString ссылку на её первые 100 символов.
При этом justString удерживает в памяти весь массив байтов,
что не позволяет сборщику мусора его освободить до конца работы программы.
При многократных вызовах функции в программе это приведёт к накоплению памяти
и, в худшем случае, к аварийному завершению программы.
В приложениях, где justString может сохраняться в других структурах (например, в слайсе или мапе),
ссылки на старые строки могут сохраняться, делая утечку постоянной.
2. Паника при недостаточной длине строки
Если createHugeString вернёт строку короче 100 символов (например, 50),
то v[:100] попытается получить доступ к несуществующим байтам, и программа завершится с паникой
Это происходит, потому что Go проверяет границы среза перед его созданием.

Как исправить
1. Копировать данные
Чтобы не удерживать всю большую строку, нужно явно копировать первые 100 символов:
justString = string([]byte(v[:100]))
или (Go ≥ 1.18):
2. Проверять длину
Перед срезом нужно убедиться, что строка не меньше 100 символов:
if len(v) < 100 {
    return "", errors.New("string too small")
}
3. Избегать глобальных переменных (опционально)
Лучше возвращать значение из функции и обрабатывать его в main
*/

// вариант исправления кода с сохранением глобальной переменной:
package main

import (
	"errors"
	"fmt"
	"strings"
)

var justString string

// someFunc копирует первые 100 символов строки в justString или возвращает ошибку.
func someFunc() error {
	v := createHugeString(1 << 10) // создается строка длиной 1024 символа
	if len(v) < 100 {
		return errors.New("string too short: length must be at least 100")
	}
	// копирование первых 100 символов, чтобы избежать утечки памяти
	justString = string([]byte(v[:100]))
	// альтернативный вариант: justString = strings.Clone(v[:100])
	return nil
}

// createHugeString (вариант) создаёт строку заданной длины, заполненную, для примера, символом 'a'
func createHugeString(length int) string {
	return strings.Repeat("a", length)
}

func main() {
	err := someFunc()
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("Result:", justString) // выводит 100 символов 'a'
}

/*
// альтернативный вариант исправления кода без глобальной переменной:
package main

import (
	"errors"
	"fmt"
	"strings"
)

// someFunc возвращает первые 100 символов строки или ошибку
func someFunc() (string, error) {
	v := createHugeString(1 << 10) // ссодается строка длиной 1024 символа
	if len(v) < 100 {
		return "", errors.New("string too short: length must be at least 100")
	}
	// копирование первых 100 символов, чтобы избежать утечки памяти
	return string([]byte(v[:100])), nil
	// альтернативный вариант: return strings.Clone(v[:100]), nil
}

// createHugeString (вариант) создаёт строку заданной длины, заполненную, для примера, символом 'a'
func createHugeString(length int) string {
	return strings.Repeat("a", length)
}

func main() {
	result, err := someFunc()
	if err != nil {
		fmt.Println("Error:", err)
		return
	}
	fmt.Println("Result:", result) // Ввыводит 100 символов 'a'
}
*/
