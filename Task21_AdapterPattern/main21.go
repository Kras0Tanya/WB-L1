package main

import "fmt"

// целевой интерфейс с новым методом
type Logger interface {
	Info(msg string)
}

// логер со старым методом, который не можем менять
type OldLogger struct{}

func (l *OldLogger) LogMessage(text string) {
	fmt.Println("[OLD LOG]:", text)
}

// адаптер, который приводит OldLogger к нужному интерфейсу Logger
type LoggerAdapter struct {
	old *OldLogger
}

// конструктор
func NewLoggerAdapter(old *OldLogger) Logger {
	return &LoggerAdapter{old: old}
}

// Info реализует интерфейс Logger и делегирует вызов методу старого логгера
func (a *LoggerAdapter) Info(msg string) {
	// переводим формат вызова с Info в LogMessage
	a.old.LogMessage(msg)
}

// код, который работает только с Logger
func ProcessRequest(log Logger) {
	log.Info("Processing request...")
	log.Info("Request completed successfully")
}

func main() {
	logger := NewLoggerAdapter(&OldLogger{})
	ProcessRequest(logger)
}

/*
Где можно применять такой адаптер:
- для интеграции со старыми библиотеками (новая система ожидает один интерфейс, а старая библиотека предоставляет другой);
- обертки над внешними апи (например, можно адаптирповать драйверы к своему интерфейсу);
- для объединения модулей (в т.ч. разные реализации могут быть приведены к одному интерфейсу).
Плюсы:
++позволяет использовать несовместимый код;
++изолирует детали реализации (клиент знает только интерфейс).
Минусы:
--усложнение структуры (если адаптеров становится слишком много).
*/

/*
Паттерн «Адаптер»
Реализовать паттерн проектирования «Адаптер» на любом примере.
Описание: паттерн Adapter позволяет сконвертировать интерфейс одного класса в интерфейс другого, который ожидает клиент.
Продемонстрируйте на простом примере в Go: у вас есть существующий интерфейс (или структура) и другой,
несовместимый по интерфейсу потребитель — напишите адаптер, который реализует нужный интерфейс
и делегирует вызовы к встроенному объекту.
Поясните применимость паттерна, его плюсы и минусы, а также приведите реальные примеры использования.
*/
