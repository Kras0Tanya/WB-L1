package main

import (
	"fmt"
)

// используется классический алгоритм "двойного разворота" (сначала строку, затем каждое слово)

func reverseWords(s string) string {
	// преобразуем строку в []byte (т.к. используется ASCII, то лучше байты - экономят память)
	b := []byte(s)
	n := len(b)

	// вспомогательная функция, разворачивающая часть массива на месте.
	// reverse(l, r) меняет местами b[l] и b[r],
	// затем сдвигает границы к центру, пока l < r.
	reverse := func(l, r int) {
		for l < r {
			b[l], b[r] = b[r], b[l]
			l, r = l+1, r-1
		}
	}

	// переворот всей строки: "snow dog sun" -> "nus god wons"
	// разворачивает порядок байт (но не порядок слов)
	if n > 0 {
		reverse(0, n-1)
	}

	// переворот каждого слова
	// проходим по строке, ищем границы слов (start ... i-1) и разворачиваем каждое слово обратно
	// "nus god wons" -> "sun dog snow"
	start := 0

	// идём до i == n включительно, чтобы обработать последнее слово
	for i := 0; i <= n; i++ {
		// если i указывает на пробел или конец строки, значит найден конец слова
		if i == n || b[i] == ' ' {

			// start < i - проверка на корректность диапазона
			// если start == i, слово пустое (например, два пробела подряд), разворота не требуется.
			if start < i {
				reverse(start, i-1)
			}

			// следующее слово начинается после пробела
			start = i + 1
		}
	}

	// преобразуем обратно в строку
	return string(b)
}

func main() {
	fmt.Println(reverseWords("snow dog sun")) // "sun dog snow"
}

/*
Разворот слов в предложении
Разработать программу, которая переворачивает порядок слов в строке.
Пример: входная строка: «snow dog sun», выход: «sun dog snow».
Считайте, что слова разделяются одиночным пробелом.
Постарайтесь не использовать дополнительные срезы, а выполнять операцию «на месте».
*/
